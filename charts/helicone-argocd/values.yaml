################################################################################
#
#                            HELICONE ARGOCD
#
################################################################################

argocd:
  enabled: true
  createProject: true
  skipCRDCheck: true
  namespace: argocd
  source:
    repoURL: "https://github.com/Helicone/helicone-helm-v3.git"
    targetRevision: main
    path: charts/helicone-core
    helm:
      valueFiles:
        - values.yaml
      parameters:
        - name: helicone.cloudnativepg.enabled
          value: "true"

  destination:
    server: https://kubernetes.default.svc
    namespace: helicone

  syncPolicy:
    automated:
      prune: true
      selfHeal: false
      allowEmpty: false
    managedNamespaceMetadata:
      labels: {}
      annotations: {}
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m

  revisionHistoryLimit: 3

argo-cd:
  enabled: true
  global:
    domain: argocd.helicone.ai

  crds:
    install: false
    keep: true

  # Service account configurations for pod identity
  controller:
    serviceAccount:
      create: true
      annotations:
        aws.amazon.com/pod-identity: "enabled"
    # Increase timeouts to handle large manifests
    args:
      operationProcessors: "20"
      statusProcessors: "40"
      appResyncPeriod: "180"
      selfHealTimeout: "10"
    env:
      - name: ARGOCD_RECONCILIATION_TIMEOUT
        value: "1800s"  # Increased from 600s to handle large resources
      - name: ARGOCD_EXEC_TIMEOUT
        value: "300s"
      - name: ARGOCD_SYNC_TIMEOUT
        value: "600s"

  repoServer:
    serviceAccount:
      create: true
      annotations:
        aws.amazon.com/pod-identity: "enabled"

  applicationSet:
    serviceAccount:
      create: true
      annotations:
        aws.amazon.com/pod-identity: "enabled"

  # Server configuration
  server:
    serviceAccount:
      create: true
      annotations:
        aws.amazon.com/pod-identity: "enabled"
    # Disable client-side validation to avoid managedFields issues
    extraArgs:
      - --disable-auth
      - --insecure
    service:
      type: ClusterIP
      servicePortHttp: 80
      servicePortHttps: 443
    ingress:
      enabled: true
      ingressClassName: nginx
      hosts:
        - argocd.helicone.ai
      tls:
        - secretName: argocd-tls
          hosts:
            - argocd.helicone.ai
      annotations:
        cert-manager.io/cluster-issuer: "letsencrypt-prod"
        nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
        nginx.ingress.kubernetes.io/service-upstream: "true"
        nginx.ingress.kubernetes.io/server-snippet: |
          grpc_read_timeout 300;
          grpc_send_timeout 300;

  # Disable Dex for simplicity (use built-in admin user)
  dex:
    enabled: false

  # Configs
  configs:
    params:
      server.insecure: false 
    
    # RBAC Configuration
    rbac:
      policy.default: role:readonly
      policy.csv: |
        # Built-in admin user
        p, role:admin, applications, *, */*, allow
        p, role:admin, clusters, *, *, allow
        p, role:admin, repositories, *, *, allow
        p, role:admin, projects, *, *, allow
        p, role:admin, accounts, *, *, allow
        p, role:admin, certificates, *, *, allow
        p, role:admin, gpgkeys, *, *, allow
        p, role:admin, logs, get, *, allow
        p, role:admin, exec, create, */*, allow
        
        # Default readonly role
        p, role:readonly, applications, get, */*, allow
        p, role:readonly, repositories, get, *, allow
        p, role:readonly, clusters, get, *, allow
        p, role:readonly, projects, get, *, allow
        
        # Group mappings (for future SSO integration)
        g, helicone:admin, role:admin
        g, helicone:developer, role:readonly
        
        # Default admin user gets admin role
        g, admin, role:admin
    